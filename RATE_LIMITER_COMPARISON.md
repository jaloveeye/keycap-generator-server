# Rate Limiter 비교: 파일 기반 vs 데이터베이스 기반

## 비교표

| 항목 | 파일 기반 | 데이터베이스 기반 (Supabase) |
|------|-----------|------------------------------|
| **설정 복잡도** | ⭐ 매우 간단 | ⭐⭐ 간단 (Supabase 이미 사용 중) |
| **추가 의존성** | ❌ 없음 | ✅ Supabase (이미 사용 중) |
| **동시성 처리** | ⚠️ 제한적 (파일 락 필요) | ✅ 우수 (DB 트랜잭션) |
| **여러 서버 인스턴스** | ❌ 불가능 | ✅ 가능 (DB 공유) |
| **성능** | ⭐⭐ 빠름 (로컬 파일) | ⭐ 빠름 (네트워크 지연) |
| **데이터 영구성** | ✅ 좋음 (파일 저장) | ✅ 매우 좋음 (DB 저장) |
| **확장성** | ❌ 제한적 | ✅ 우수 |
| **서버 재시작 후 유지** | ✅ 가능 | ✅ 가능 |
| **자동 정리** | ⚠️ 수동 또는 주기적 | ✅ 가능 (SQL 함수) |
| **에러 처리** | ⚠️ 파일 I/O 에러 | ✅ DB 에러 처리 |

## 상세 비교

### 파일 기반 (`FileBasedRateLimiter`)

#### 장점
- ✅ **설정 불필요**: 파일만 생성하면 됨
- ✅ **빠른 성능**: 로컬 파일 I/O
- ✅ **추가 의존성 없음**: Redis나 DB 불필요
- ✅ **서버 재시작 후 유지**: 파일에 저장

#### 단점
- ⚠️ **동시성 문제**: 여러 요청이 동시에 파일을 수정할 때 충돌 가능
- ⚠️ **여러 서버 인스턴스 불가**: 각 서버가 독립적인 파일 사용
- ⚠️ **파일 I/O 오버헤드**: 매 요청마다 파일 읽기/쓰기
- ⚠️ **확장성 제한**: 서버가 많아지면 관리 어려움

#### 사용 시나리오
- 단일 서버 환경
- 개발/테스트 환경
- 트래픽이 적은 프로덕션

### 데이터베이스 기반 (`DatabaseBasedRateLimiter`)

#### 장점
- ✅ **동시성 처리 우수**: DB 트랜잭션으로 안전
- ✅ **여러 서버 인스턴스 지원**: 모든 서버가 같은 DB 사용
- ✅ **확장성 우수**: 서버를 늘려도 문제없음
- ✅ **자동 정리**: SQL 함수로 만료 데이터 삭제
- ✅ **이미 Supabase 사용 중**: 추가 설정 최소화

#### 단점
- ⚠️ **네트워크 지연**: DB 쿼리 오버헤드
- ⚠️ **초기 설정 필요**: 테이블 생성 필요
- ⚠️ **DB 비용**: Supabase 무료 티어 사용 가능

#### 사용 시나리오
- 여러 서버 인스턴스 (로드 밸런싱)
- 높은 트래픽
- 프로덕션 환경

## 추천

### 개발/테스트 환경
**파일 기반 추천**
- 설정이 간단하고 빠름
- Redis나 DB 설정 불필요

### 프로덕션 환경
**데이터베이스 기반 추천** (Supabase)
- 이미 Supabase 사용 중이므로 추가 비용 없음
- 여러 서버 인스턴스 지원
- 동시성 처리 우수

## 구현 상태

현재 코드는 **3단계 폴백** 구조로 구현되어 있습니다:

1. **1순위**: Redis (가장 빠름, 여러 서버 지원)
2. **2순위**: 파일 기반 (Redis 없을 때, 서버 재시작 후 유지)
3. **3순위**: 메모리 기반 (Redis와 파일 모두 없을 때, 서버 재시작 시 초기화)

데이터베이스 기반도 추가할 수 있습니다. 원하시면 구현하겠습니다!

## 데이터베이스 기반 추가 방법

1. Supabase SQL Editor에서 `SUPABASE_RATE_LIMIT_SETUP.sql` 실행
2. `RateLimiter`에 데이터베이스 옵션 추가
3. 환경 변수로 선택 가능하게 설정

원하시면 구현해드리겠습니다!

